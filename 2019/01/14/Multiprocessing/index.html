<!DOCTYPE html>
<html lang="">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Multiprocessing">




  <meta name="keywords" content="Python, 磊哥的小书桌">










  <link rel="alternate" href="/default" title="磊哥的小书桌">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1">



<link rel="canonical" href="https://geolibra.github.io/2019/01/14/Multiprocessing/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1">



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?97659041a2db55d3eb7266f53be7c071";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "ro3TOe5F5DDemxHnSoYVCHli-gzGzoHsz",
      appKey: "IHyD5EfrggPl57FnwtBEeH0W"
    });
  </script>




<script>
  window.config = {"title":"磊哥的小书桌","subtitle":null,"description":null,"author":"hgis","language":null,"timezone":null,"url":"https://geolibra.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":true,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repository":"git@github.com:GeoLibra/GeoLibra.github.io.git","branch":"master"},"ignore":[],"keywords":null,"email":"674530915@qq.com","index_generator":{"per_page":10,"order_by":"-date","path":""},"tag_cloud":{"textFont":"Trebuchet MS, Helvetica","textColour":"\\#eea849","textHeight":25,"outlineColour":"\\#E2E1D1"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"compress":false,"header":true},"since":2018,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","Categories":"/categories","About":"/about"},"color":"default","mode":"default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"license":"<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>"},"reward":{"enable":false,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"674530915@qq.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/GeoLibra","weibo":null,"zhihu":null,"douban":null,"pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":"ro3TOe5F5DDemxHnSoYVCHli-gzGzoHsz","app_key":"IHyD5EfrggPl57FnwtBEeH0W"},"baidu_analytics":"97659041a2db55d3eb7266f53be7c071","baidu_verification":null,"google_analytics":null,"google_verification":null,"disqus_shortname":null,"changyan":{"appid":null,"appkey":null},"livere_datauid":null,"counter":true,"version":"2.10.1"};
</script>

    <title> Multiprocessing - 磊哥的小书桌 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">磊哥的小书桌</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">磊哥的小书桌</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Multiprocessing
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-14
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Python/">Python</a>
            
          </span>
        
        
        <span class="post-visits" data-url="/2019/01/14/Multiprocessing/" data-title="Multiprocessing">
          阅读次数 0
        </span>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Multiprocessing进程管理模块"><span class="toc-text">Multiprocessing进程管理模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Process模块"><span class="toc-text">Process模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pool模块"><span class="toc-text">Pool模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程通信"><span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue模块"><span class="toc-text">Queue模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipe模块"><span class="toc-text">Pipe模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Manager模块"><span class="toc-text">Manager模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multiprocessing同步进程模块"><span class="toc-text">Multiprocessing同步进程模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock模块"><span class="toc-text">Lock模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore模块"><span class="toc-text">Semaphore模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event模块"><span class="toc-text">Event模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题"><span class="toc-text">问题</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>　　python使用全局解释器锁(GIL)，他会将进程中的线程序列化，也就是多核cpu实际上并不能达到并行提高速度的目的，而使用多进程则是不受限的，所以实际应用中都是推荐多进程的。使用多进程往往是用来处理CPU密集型（科学计算）的需求，如果是IO密集型（文件读取，爬虫等）则可以使用多线程去处理。<a id="more"></a></p>
<blockquote>
<p>尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。 GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。GIL只会影响到那些严重依赖CPU的程序（比如计算型的）。 如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。实际上，你完全可以放心的创建几千个Python线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p>
</blockquote>
<p><strong>multiprocessing常用组件及功能</strong>  </p>
<ul>
<li><p>创建管理进程的模块</p>
<ul>
<li>Process：用于创建进程模块</li>
<li>Pool：用于创建管理进行池</li>
<li>Queue：用于进程通信，资源共享</li>
<li>Value，Array：用于进程通信，资源共享</li>
<li>Pipe：用于管道通信</li>
<li>Manager：用于资源共享</li>
</ul>
</li>
<li><p>同步子进程模块</p>
<ul>
<li>Condition</li>
<li>Event</li>
<li>Lock</li>
<li>RLock</li>
<li>Semaphore</li>
</ul>
</li>
</ul>
<h2 id="Multiprocessing进程管理模块"><a href="#Multiprocessing进程管理模块" class="headerlink" title="Multiprocessing进程管理模块"></a>Multiprocessing进程管理模块</h2><h3 id="Process模块"><a href="#Process模块" class="headerlink" title="Process模块"></a>Process模块</h3><p>　　Process模块用来创建子进程，是Multiprocessing核心模块，使用方式与Threading类似，可以实现多进程的创建，启动，关闭等操作。<br><strong>构造方法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])</span><br></pre></td></tr></table></figure></p>
<ul>
<li>group: 线程组，目前还没有实现，库引用中提示必须是None；  </li>
<li>target: 要执行的方法；  </li>
<li>name: 进程名；  </li>
<li>args/kwargs: 要传入方法的参数。  </li>
</ul>
<p><strong>实例方法</strong>  </p>
<ul>
<li>is_alive():进程是否在运行  </li>
<li>join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。</li>
<li>start()：进程准备就绪，等待CPU调度。</li>
<li>run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。</li>
<li>terminate()：不管任务是否完成，立即停止工作进程。</li>
</ul>
<p><strong>属性</strong>  </p>
<ul>
<li>authkey</li>
<li>daemon：和线程的setDaemon功能一样，将父进程设置为守护进程，当父进程结束时，子进程也结束</li>
<li>exitcode：进程在运行时为none，如果为-N，表示信号N结束</li>
<li>name：进程的名字</li>
<li>pid：进程号</li>
</ul>
<p><strong>创建多进程的两种方法</strong></p>
<ul>
<li><p>使用Process创建子进程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(title)</span>:</span></span><br><span class="line">    print(title)</span><br><span class="line">    print(<span class="string">'module name:'</span>, __name__)</span><br><span class="line">    <span class="keyword">if</span> hasattr(os, <span class="string">'getppid'</span>):  <span class="comment"># only available on Unix</span></span><br><span class="line">        print(<span class="string">'parent process:'</span>, os.getppid())</span><br><span class="line">    print(<span class="string">'process id:'</span>, os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    info(<span class="string">'function f'</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    info(<span class="string">'main line'</span>)</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Process类继承创建子进程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        super(MyProcess, self).__init__()</span><br><span class="line">        <span class="comment">#multiprocessing.Process.__init__(self)</span></span><br><span class="line">        self.arg = arg</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'nMask'</span>, self.arg)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = MyProcess(i)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Pool模块"><a href="#Pool模块" class="headerlink" title="Pool模块"></a>Pool模块</h3><p>　　Multiprocessing.Pool可以提供指定数量的进程供用户调用，当有新的请求提交到pool中时，如果还没满，就会创建一个新的进程来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。在共享资源时只能使用Multiprocessing.Manager，而不能使用Queue或Array。<br><strong>用途</strong><br>Pool类用于需要执行的目标很多，而手动限制进程数量又太繁琐时，如果目标少且不用控制进程数量则可以用Process类。<br><strong>构造方法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])</span><br></pre></td></tr></table></figure></p>
<ul>
<li>processes:使用的工作进程的数量，如果processes是None，那么使用os.cpu_count()返回的数量</li>
<li>initializer:如果initializer是None，那么每一个工作进行在开始的时候会调用initializer(*initargs)</li>
<li>maxtasksperchild:工作进程退出之前可以完成的任务数，完成后一个新的工作进程来代替原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要pool存在工作进程就会一直存活。</li>
<li>context:用在制定工作进程启动时的上下文，一般使用multiprocessing.Pool()或一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context</li>
</ul>
<p><strong>实例方法</strong>  </p>
<ul>
<li>apply_async(func[, args[, kwds[, callback]]]) 它是非阻塞</li>
<li>apply(func[, args[, kwds]])是阻塞的</li>
<li>close() 关闭pool，使其不在接受新的任务</li>
<li>terminate() 关闭pool，结束工作进程，不在处理未完成的任务</li>
<li>join() 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用</li>
</ul>
<p><strong>使用方法</strong>  </p>
<ul>
<li>Pool+map<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rom multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">	lists=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">	pool=Pool(processes=<span class="number">2</span>) <span class="comment">#定义最大的进程数</span></span><br><span class="line">	pool.map(test,lists)        <span class="comment">#p必须是一个可迭代变量。</span></span><br><span class="line">	pool.close()</span><br><span class="line">	pool.join()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>initializer的使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_calculation</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> data*<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_process</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Starting'</span>,multiprocessing.current_process().name)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    inputs=list(range(<span class="number">10</span>))</span><br><span class="line">    print(<span class="string">'Inputs  :'</span>,inputs)</span><br><span class="line">    builtin_output=map(do_calculation,inputs)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Build-In :'</span>, builtin_output)</span><br><span class="line">    pool_size=multiprocessing.cpu_count()*<span class="number">2</span></span><br><span class="line">    pool=multiprocessing.Pool(processes=pool_size,</span><br><span class="line">        initializer=start_process,)</span><br><span class="line">    pool_outputs=pool.map(do_calculation,inputs)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    print(<span class="string">'Pool  :'</span>,pool_outputs)</span><br></pre></td></tr></table></figure></p>
<p><strong>异步进程池（非阻塞）</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t_start=time.time()</span><br><span class="line">    pool = Pool(processes=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        for循环执行步骤</span></span><br><span class="line"><span class="string">        1.循环遍历,将100个子进程添加到进程池(相对父进程会阻塞)</span></span><br><span class="line"><span class="string">        2.每次执行10个子进程,等一个子进程执行完后,立马启动新的子进程(相对父进程不阻塞)</span></span><br><span class="line"><span class="string">        apply_async为异步进程池写法</span></span><br><span class="line"><span class="string">        异步指的是启动子进程的过程,与父进程本身的执行(print)是异步的,而for循环中往进程池添加子进程的过程,与父进程本身的执行却是同步的</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        pool.apply_async(func=f, args=(i,)) <span class="comment">#维持执行的进程总数为10，当一个进程执行完后启动一个新进程.</span></span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  </span><br><span class="line">    t_end=time.time()</span><br><span class="line">    t=t_end-t_start</span><br><span class="line">    print(<span class="string">'the program time is :%s'</span> %t)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：调用join之前，先调用close或者terminate方法，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束。</p>
</blockquote>
<p><strong>同步进程池(阻塞)</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t_start=time.time()</span><br><span class="line">    pool = Pool(processes=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        for循环执行步骤</span></span><br><span class="line"><span class="string">        1.遍历100个可迭代对象,往进程池放一个子进程</span></span><br><span class="line"><span class="string">        2.执行这个子进程,等子进程执行完毕,再往进程池放一个子进程,再执行(同时只执行一个子进程)</span></span><br><span class="line"><span class="string">        for循环执行完毕,再执行print函数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        pool.apply_async(f, args=(i,)) <span class="comment"># 维持执行的进程总数为10,当一个进程执行完后启动一个新进程</span></span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    t_end=time.time()</span><br><span class="line">    t=t_end-t_start</span><br><span class="line">    print(<span class="string">'the program time is :%s'</span> %t)</span><br></pre></td></tr></table></figure></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="Queue模块"><a href="#Queue模块" class="headerlink" title="Queue模块"></a>Queue模块</h3><p>　　Queue模块用来控制进程安全，与线程中的Queue用法一样。Queue的功能是将每个核或线程的运算结果放在队里中， 等到每个线程或核运行完毕后再从队列中取出结果， 继续加载运算。原因很简单, 多线程调用的函数不能有返回值, 所以使用Queue存储多个线程运算的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="comment"># 定义一个被多线程调用的函数，q像一个队列，用来保存每次函数运行的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(q)</span>:</span></span><br><span class="line">    res=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        res+=i+i**<span class="number">2</span>+i**<span class="number">3</span></span><br><span class="line">    q.put(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 定义一个多线程队列</span></span><br><span class="line">    q=mp.Queue()</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    定义两个线程函数,用来处理同一个任务,args的参数只要一个值的时候,参数后面需要加一个逗号,表示args是可迭代的,后面可能还有别的参数,不加逗号会出错</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    p1=mp.Process(target=job,args=(q,))</span><br><span class="line">    p2=mp.Process(target=job,args=(q,))</span><br><span class="line">    <span class="comment"># 分别启动 连接两个线程</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    <span class="comment"># 上面是分两批处理的  所以这里分两批输出 将结果分别保存</span></span><br><span class="line">    res1=q.get()</span><br><span class="line">    res2=q.get()</span><br><span class="line">    print(res1,res2)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Queues是线程进程安全的</p>
</blockquote>
<h3 id="Pipe模块"><a href="#Pipe模块" class="headerlink" title="Pipe模块"></a>Pipe模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Pipe</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send([<span class="number">42</span>,<span class="keyword">None</span>,<span class="string">'hello'</span>])</span><br><span class="line">    conn.close()</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn,child_conn=Pipe()</span><br><span class="line">    p=Process(target=f,args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p>第二个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(dict(name=<span class="string">'Bob'</span>, spam=<span class="number">42</span>))            <span class="comment"># 传输一个字典</span></span><br><span class="line">    reply = pipe.recv()                             <span class="comment"># 接收传输的数据</span></span><br><span class="line">    print(<span class="string">'talker got:'</span>, reply)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    (parentEnd, childEnd) = Pipe()                  <span class="comment"># 创建两个 Pipe() 实例，也可以改成 conf1， conf2</span></span><br><span class="line">    child = Process(target=talk, args=(childEnd,))  <span class="comment"># 创建一个 Process 进程，名称为 child</span></span><br><span class="line">    child.start()                                   <span class="comment"># 启动进程</span></span><br><span class="line">    print(<span class="string">'parent got:'</span>, parentEnd.recv())          <span class="comment"># parentEnd 是一个 Pip() 管道，可以接收 child Process 进程传输的数据</span></span><br><span class="line">    parentEnd.send(&#123;x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spam'</span>&#125;)         <span class="comment"># parentEnd 是一个 Pip() 管道，可以使用 send 方法来传输数据</span></span><br><span class="line">    child.join()                                    <span class="comment"># 传输的数据被 talk 函数内的 pip 管道接收，并赋值给 reply</span></span><br><span class="line">    print(<span class="string">'parent exit'</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="Manager模块"><a href="#Manager模块" class="headerlink" title="Manager模块"></a>Manager模块</h3><p>　　Manager模块常与Pool模块一起使用，作用是共享资源。</p>
<h2 id="Multiprocessing同步进程模块"><a href="#Multiprocessing同步进程模块" class="headerlink" title="Multiprocessing同步进程模块"></a>Multiprocessing同步进程模块</h2><h3 id="Lock模块"><a href="#Lock模块" class="headerlink" title="Lock模块"></a>Lock模块</h3><p>　　作用：当多个进程需要访问共享资源的时候，Lock可以用来避免访问的冲突。<br>　　具体场景：所有的任务在打印的时候都会向同一个标准输出(stdout)输出。这样输出的字符会混合在一起，无法阅读。使用Lock同步，在一个任务输出完成之后，再允许另一个任务输出，可以避免多个任务同时向终端输出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l</span><span class="params">(lock,num)</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    print(<span class="string">"Hello Num:%s"</span> % num)</span><br><span class="line">    lock.release()</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Process(target=l,args=(lock,num)).start()</span><br></pre></td></tr></table></figure></p>
<h3 id="Semaphore模块"><a href="#Semaphore模块" class="headerlink" title="Semaphore模块"></a>Semaphore模块</h3><p>　　作用：用来控制对共享资源的访问数量，例如池的最大连接数。</p>
<h3 id="Event模块"><a href="#Event模块" class="headerlink" title="Event模块"></a>Event模块</h3><p>　　作用：用来实现进程间同步通信。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>启动多进程的代码一定要放在 if name==”main“: 后面吗？<br>windows系统下，想要启动一个子进程，必须加上if name==”main“:，linux则不需要。</li>
<li>父进程中的全局变量能被子进程共享吗？<br>不行，因为每个进程享有独立的内存数据，如果想要共享资源，可以使用Manage类，或者Queue等模块。</li>
<li>子进程能结束其他子进程或父进程吗？如果能，怎么通过子进程去结束所有进程?<br>此需求可以稍作修改：所有的子进程都是为了完成一件事情，而当某个子进程完成该事情后，父进程就该结束所有子进程，请问该怎么做？此时结束所有子进程的操作可以交给父进程去做，因为子进程想要结束另外的子进程比较难实现。<br>那么问题就又变成了父进程什么时候该结束所有进程？其中一个思路是获取每个子进程的返回值，一旦有返回True（结束的标记），则立马结束所有进程；另外一种思路是使用共享资源，父进程可以一直去判断这个公共资源，一旦子进程将它改变，则结束所有子进程。（推荐使用前者，因为多进程中不推荐使用资源共享）</li>
<li>子进程中还能再创建子进程吗？<br>可以，子进程可以再创建进程，线程中也可以创建进程。</li>
</ol>
<p>参考：<br><a href="http://python.jobbole.com/87760/" target="_blank" rel="noopener">http://python.jobbole.com/87760/</a><br><a href="http://python.jobbole.com/87645/" target="_blank" rel="noopener">http://python.jobbole.com/87645/</a></p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://geolibra.github.io">hgis</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://geolibra.github.io/2019/01/14/Multiprocessing/">https://geolibra.github.io/2019/01/14/Multiprocessing/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Python/">Python</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/01/14/Caffe实现实现MNIST实例/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Caffe实现实现MNIST实例</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/01/06/logging模块的使用/">
        <span class="next-text nav-default">logging模块的使用</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:674530915@qq.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/GeoLibra" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>


  <span class="copyright-year">
    
    &copy; 
     
      2018 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">hgis</span>
    <span id="busuanzi_container_site_uv">
    </span>
</span>
</div>



      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
